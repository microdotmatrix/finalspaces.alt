import { UnifiedQuote } from "@/types/quotes";
import { eq } from "drizzle-orm";
import { headers } from "next/headers";
import { redirect } from "next/navigation";
import { cache } from "react";
import { auth } from "../auth";
import { db } from "./index";
import {
  obituaries,
  obituariesDraft,
  Obituary,
  ObituaryDraft,
  savedQuotes,
  userGeneratedImage,
  userUpload,
} from "./schema";
/**
 * Fetches user uploads from the database
 * @returns Array of user uploads or null if user is not authenticated
 */
export const getUserUploads = cache(async (userId: string) => {
  // Fetch all uploads for this user
  const uploads = await db.query.userUpload.findMany({
    where: eq(userUpload.userId, userId),
    orderBy: (uploads, { desc }) => [desc(uploads.createdAt)],
  });

  return uploads;
});

/**
 * Fetches user uploads from the database, redirects to login if not authenticated
 * @param redirectUrl URL to redirect to if user is not authenticated
 * @returns Array of user uploads
 */
export const getUserUploadsOrRedirect = cache(
  async (redirectUrl = "/auth/login") => {
    // Get the current user session
    const session = await auth.api.getSession({ headers: await headers() });

    // If no session exists, redirect to login
    if (!session) {
      redirect(redirectUrl);
    }

    // Get the user ID from the session
    const userId = session.user.id;

    // Fetch all uploads for this user
    const uploads = await db.query.userUpload.findMany({
      where: eq(userUpload.userId, userId),
      orderBy: (uploads, { desc }) => [desc(uploads.createdAt)],
    });

    return uploads;
  }
);

/**
 * Fetches epitaph IDs for images generated by a specific user
 * @param userId User ID to fetch epitaph IDs for
 * @returns Array of user generated images with their epitaph IDs
 */
export const getUserGeneratedEpitaphIds = cache(async (userId: string) => {
  // Fetch all generated images for this user
  const generatedImages = await db.query.userGeneratedImage.findMany({
    where: eq(userGeneratedImage.userId, userId),
    orderBy: (images, { desc }) => [desc(images.createdAt)],
  });

  // Return the epitaph IDs
  return generatedImages.map((image) => image.epitaphId);
});

/**
 * Fetches all user generated images from the database
 * @param userId User ID to fetch generated images for
 * @returns Array of user generated images or empty array if none found
 */
export const getUserGeneratedImages = cache(async (userId: string) => {
  // Fetch all generated images for this user
  const generatedImages = await db.query.userGeneratedImage.findMany({
    where: eq(userGeneratedImage.userId, userId),
    orderBy: (images, { desc }) => [desc(images.createdAt)],
  });

  return generatedImages;
});

/**
 * Fetches epitaph IDs for images generated by the current user or redirects to login
 * @param redirectUrl URL to redirect to if user is not authenticated
 * @returns Array of epitaph IDs
 */
export const getUserGeneratedEpitaphIdsOrRedirect = cache(
  async (redirectUrl = "/auth/login") => {
    // Get the current user session
    const session = await auth.api.getSession({ headers: await headers() });

    // If no session exists, redirect to login
    if (!session) {
      redirect(redirectUrl);
    }

    // Get the user ID from the session
    const userId = session.user.id;

    // Fetch all generated images for this user
    const generatedImages = await db.query.userGeneratedImage.findMany({
      where: eq(userGeneratedImage.userId, userId),
      orderBy: (images) => images.createdAt,
    });

    // Return the epitaph IDs
    return generatedImages.map((image) => image.epitaphId);
  }
);

/**
 * Get all saved quotes for the current user
 * Returns an array of quote identifiers (quote text and author)
 */
export const getUserSavedQuotes: () => Promise<{
  quotes: UnifiedQuote[];
  savedQuotesMap: Map<string, boolean>;
}> = cache(async () => {
  // Get the current session
  const session = await auth.api.getSession({ headers: await headers() });

  if (!session || !session.user) {
    return { quotes: [], savedQuotesMap: new Map() };
  }

  try {
    const userId = session.user.id;

    const result = await db.query.savedQuotes.findMany({
      where: eq(savedQuotes.userId, userId),
    });

    const savedQuotesMap = new Map<string, boolean>();

    result.forEach((sq) => {
      const key = `${sq.quote}|${sq.author}`;
      savedQuotesMap.set(key, true);
    });

    // Convert saved quotes to UnifiedQuote format for the QuoteCard component
    const quotes: UnifiedQuote[] = result.map((sq) => ({
      quote: sq.quote,
      author: sq.author,
      source: "Saved Quote", // Default source for saved quotes
      length: sq.quote.length,
    }));

    return { quotes, savedQuotesMap };
  } catch (error) {
    console.error("Error fetching saved quotes:", error);
    return { quotes: [], savedQuotesMap: new Map() };
  }
});

export const getUserObituaries: () => Promise<Obituary[]> = cache(async () => {
  const session = await auth.api.getSession({ headers: await headers() });

  if (!session || !session.user) {
    return [];
  }

  try {
    const userId = session.user.id;

    const result = await db.query.obituaries.findMany({
      where: eq(obituaries.userId, userId),
    });

    return result;
  } catch (error) {
    console.error("Error fetching obituaries:", error);
    return [];
  }
});

export const getUserObituariesDraft: () => Promise<ObituaryDraft[]> = cache(
  async () => {
    const session = await auth.api.getSession({ headers: await headers() });

    if (!session || !session.user) {
      return [];
    }

    try {
      const userId = session.user.id;

      const result = await db.query.obituariesDraft.findMany({
        where: eq(obituariesDraft.userId, userId),
      });

      return result;
    } catch (error) {
      console.error("Error fetching obituaries:", error);
      return [];
    }
  }
);
